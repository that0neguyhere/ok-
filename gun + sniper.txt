--reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
--the code that looks trash and works great
local healthHide = false --moves your head away every 3 seconds so players dont see your health bar (alignmode 4 only)
local reclaim = true --if you lost control over a part this will move your primary part to the part so you get it back (alignmode 4)
local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them (alignmode 4 only)
local physp = nil --PhysicalProperties.new(0.01, 0, 1, 0, 0) --sets .CustomPhysicalProperties to this for each part
local noclipAllParts = false --set it to true if you want noclip
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local simrad = 1000 --simulation radius with sethiddenproperty (nil to disable)
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to load)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 1 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
--4 - no AlignPosition, CFrame only
local flingpart = "HumanoidRootPart" --name of the part or the hat used for flinging
--the fling function
--usage: fling(target, duration, velocity)
--target can be set to: basePart, CFrame, Vector3, character model or humanoid (flings at mouse.Hit if argument not provided)
--duration (fling time in seconds) can be set to a number or a string convertable to a number (0.5s if not provided)
--velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)

local lp = game:GetService("Players").LocalPlayer
local rs, ws, sg = game:GetService("RunService"), game:GetService("Workspace"), game:GetService("StarterGui")
local stepped, heartbeat, renderstepped = rs.Stepped, rs.Heartbeat, rs.RenderStepped
local twait, tdelay, rad, inf, abs, mclamp = task.wait, task.delay, math.rad, math.huge, math.abs, math.clamp
local cf, v3, angles = CFrame.new, Vector3.new, CFrame.Angles
local v3_0, cf_0 = v3(0, 0, 0), cf(0, 0, 0)

local c = lp.Character
pcall(function()
	c:WaitForChild('RockAccessory', 2):WaitForChild('Handle', 2):FindFirstChildOfClass('SpecialMesh'):Destroy()
end)
if not (c and c.Parent) then
	return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
	if not (c and c.Parent) then
		c = nil
	end
end)

local destroy = c.Destroy

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local v3_xz, v3_net = v3(8, 0, 8), v3(0.1, 25.1, 0.1)
local function getNetlessVelocity(realPartVelocity) --edit this if you have a better netless method
	if realPartVelocity.Magnitude < 0.1 then return v3_net end
	return realPartVelocity * v3_xz + v3_net
end

if type(simrad) == "number" then
	local shp = getfenv().sethiddenproperty
	if shp then
		local con = nil
		con = heartbeat:Connect(function()
			if not c then return con:Disconnect() end
			pcall(function()
				shp(lp, "SimulationRadius", simrad)
			end)
		end)
	end
end

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 3)) and gp(c, "Head", "BasePart")

local reclaim, lostpart = reclaim and c.PrimaryPart, nil

local v3_hide = v3(0, 3000, 0)
local function align(Part0, Part1)

	local att0 = Instance.new("Attachment")
	att0.Position, att0.Orientation, att0.Name = v3_0, v3_0, "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment")
	att1.Position, att1.Orientation, att1.Name = v3_0, v3_0, "att1_" .. Part1.Name

	if alignmode == 4 then

		local hide = false
		if Part0 == healthHide then
			healthHide = false
			tdelay(0, function()
				while twait(2.9) and Part0 and c do
					hide = #Part0:GetConnectedParts() == 1
					twait(0.1)
					hide = false
				end
			end)
		end

		local rot = rad(0.05)
		local con0, con1 = nil, nil
		con0 = stepped:Connect(function()
			if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
			Part0.RotVelocity = Part1.RotVelocity
		end)
		local lastpos, vel = Part0.Position, Part0.Velocity
		con1 = heartbeat:Connect(function(delta)
			if not (Part0 and Part1 and att1) then return con0:Disconnect() and con1:Disconnect() end
			if (not Part0.Anchored) and (Part0.ReceiveAge == 0) then
				if lostpart == Part0 then
					lostpart = nil
				end
				local newcf = Part1.CFrame * att1.CFrame
				local vel = (newcf.Position - lastpos) / delta
				Part0.Velocity = getNetlessVelocity(vel)
				if vel.Magnitude < 1 then
					rot = -rot
					newcf *= angles(0, 0, rot)
				end
				lastpos = newcf.Position
				if lostpart and (Part0 == reclaim) then
					newcf = lostpart.CFrame
				elseif hide then
					newcf += v3_hide
				end
				if novoid and (newcf.Y < ws.FallenPartsDestroyHeight + 0.1) then
					newcf += v3(0, ws.FallenPartsDestroyHeight + 0.1 - newcf.Y, 0)
				end
				Part0.CFrame = newcf
			elseif (not Part0.Anchored) and (abs(Part0.Velocity.X) < 45) and (abs(Part0.Velocity.Y) < 25) and (abs(Part0.Velocity.Z) < 45) then
				lostpart = Part0
			end
		end)

	else

		Part0.CustomPhysicalProperties = physp
		if (alignmode == 1) or (alignmode == 2) then
			local ape = Instance.new("AlignPosition")
			ape.MaxForce, ape.MaxVelocity, ape.Responsiveness = inf, inf, inf
			ape.ReactionForceEnabled, ape.RigidityEnabled, ape.ApplyAtCenterOfMass = false, true, false
			ape.Attachment0, ape.Attachment1, ape.Name = att0, att1, "AlignPositionRtrue"
			ape.Parent = att0
		end

		if (alignmode == 2) or (alignmode == 3) then
			local apd = Instance.new("AlignPosition")
			apd.MaxForce, apd.MaxVelocity, apd.Responsiveness = inf, inf, inf
			apd.ReactionForceEnabled, apd.RigidityEnabled, apd.ApplyAtCenterOfMass = false, false, false
			apd.Attachment0, apd.Attachment1, apd.Name = att0, att1, "AlignPositionRfalse"
			apd.Parent = att0
		end

		local ao = Instance.new("AlignOrientation")
		ao.MaxAngularVelocity, ao.MaxTorque, ao.Responsiveness = inf, inf, inf
		ao.PrimaryAxisOnly, ao.ReactionTorqueEnabled, ao.RigidityEnabled = false, false, false
		ao.Attachment0, ao.Attachment1 = att0, att1
		ao.Parent = att0

		local con0, con1 = nil, nil
		local vel = Part0.Velocity
		con0 = renderstepped:Connect(function()
			if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
			--Part0.Velocity = framevel -- this is completely useless and is spamming a ton of error messages
		end)
		local lastpos = Part0.Position
		con1 = heartbeat:Connect(function(delta)
			if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
			vel = Part0.Velocity
			Part0.Velocity = getNetlessVelocity((Part1.Position - lastpos) / delta)
			lastpos = Part1.Position
		end)

	end

	att0:GetPropertyChangedSignal("Parent"):Connect(function()
		Part0 = att0.Parent
		if not Part0:IsA("BasePart") then
			att0 = nil
			if lostpart == Part0 then
				lostpart = nil
			end
			Part0 = nil
		end
	end)
	att0.Parent = Part0

	att1:GetPropertyChangedSignal("Parent"):Connect(function()
		Part1 = att1.Parent
		if not Part1:IsA("BasePart") then
			att1 = nil
			Part1 = nil
		end
	end)
	att1.Parent = Part1
end

local function respawnrequest()
	local ccfr, c = ws.CurrentCamera.CFrame, lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
		if (prop ~= "Parent") and (prop ~= "CFrame") then
			return
		end
		ws.CurrentCamera.CFrame = ccfr
		con:Disconnect()
	end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and lp:FindFirstChildOfClass("Backpack")

if antiragdoll then
	antiragdoll = function(v)
		if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
			v.Parent = nil
		end
	end
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	twait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetDescendants()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		OLDscripts[v.Name] = true
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName, exists = tostring(i), true
		while exists do
			exists = OLDscripts[newName]
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
c.Archivable = true
local cl = c:Clone()
if hum and humState16 then
	hum:ChangeState(Enum.HumanoidStateType.Physics)
	if destroyhum then
		twait(1.6)
	end
end
if destroyhum then
	pcall(destroy, hum)
end

if not c then
	return
end

local head, torso, root = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart"), gp(c, "HumanoidRootPart", "BasePart")
if hatcollide then
	pcall(destroy, torso)
	pcall(destroy, root)
	pcall(destroy, c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script"))
end

local model = Instance.new("Model", c)
model:GetPropertyChangedSignal("Parent"):Connect(function()
	if not (model and model.Parent) then
		model = nil
	end
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity")
					bv.Velocity, bv.MaxForce, bv.P, bv.Name = v3_0, v3(1000, 1000, 1000), 1250, "bv_" .. v.Name
					bv.Parent = v1
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("JointInstance") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					pcall(destroy, v)
				end
			end
		end
	end
	if method == 3 then
		task.delay(loadtime, pcall, model.BreakJoints, model)
	end
end

cl.Parent = ws
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
pcall(destroy, cl)

local uncollide, noclipcon = nil, nil
if noclipAllParts then
	uncollide = function()
		if c then
			for i, v in pairs(c:GetDescendants()) do
				if v:IsA("BasePart") then
					v.CanCollide = false
				end
			end
		else
			noclipcon:Disconnect()
		end
	end
else
	uncollide = function()
		if model then
			for i, v in pairs(model:GetDescendants()) do
				if v:IsA("BasePart") then
					v.CanCollide = false
				end
			end
		else
			noclipcon:Disconnect()
		end
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						pcall(destroy, scr)
						pcall(destroy, scr1)
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent and (not v:IsDescendantOf(model)) then
		if v:IsA("Decal") then
			v.Transparency = 1
		elseif v:IsA("BasePart") then
			v.Transparency = 1
			v.Anchored = false
		elseif v:IsA("ForceField") then
			v.Visible = false
		elseif v:IsA("Sound") then
			v.Playing = false
		elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
			v.Enabled = false
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
if hum0 then
	hum0:GetPropertyChangedSignal("Parent"):Connect(function()
		if not (hum0 and hum0.Parent) then
			hum0 = nil
		end
	end)
end
if hum1 then
	hum1:GetPropertyChangedSignal("Parent"):Connect(function()
		if not (hum1 and hum1.Parent) then
			hum1 = nil
		end
	end)

	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	pcall(destroy, rb)
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		if c then c:BreakJoints() end
		return
	end
	if model and hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
		respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

tdelay(0, function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
	local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
		local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.849,
					LeftLowerArm = -0.174,
					LeftUpperArm = 0.415
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.849,
					RightLowerArm = -0.174,
					RightUpperArm = 0.415
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.29,
					LeftUpperLeg = 0.49
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.29,
					RightUpperLeg = 0.49
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(c:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name, part.Size, part.CFrame, part.Anchored, part.Transparency, part.CanCollide = v.Name, v.Size, cfr, false, 1, false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld")
					weld.Part0, weld.Part1, weld.C0, weld.C1, weld.Name = part, R15part, cf(0, v1, 0), cf_0, "Weld_" .. i1
					weld.Parent = R15part
					R15part.Massless, R15part.Name = true, "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Position = v3(0, v1, 0)
						att.Parent = part
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		if hum1 then
			hum1.RigType, hum1.HipHeight = Enum.HumanoidRigType.R6, 0
		end
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck, conTorso, conTorso1 = nil, nil, nil
	local aligns = {}
	local function enableAligns()
		conNeck:Disconnect()
		conTorso:Disconnect()
		conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
		if table.find({"Part0", "Part1", "Parent"}, prop) then
			enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v:GetPropertyChangedSignal("Parent"):Connect(function()
				aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
pcall(function()
	flingpart0.Transparency = 0
end)
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
	flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
		if not (flingpart0 and flingpart0.Parent) then
			flingpart0 = nil
			fling = function() end
		end
	end)
	flingpart0.Archivable = true
	flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
		if not (flingpart1 and flingpart1.Parent) then
			flingpart1 = nil
			fling = function() end
		end
	end)
	local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
	local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
	if att0 and att1 then
		att0:GetPropertyChangedSignal("Parent"):Connect(function()
			if not (att0 and att0.Parent) then
				att0 = nil
				fling = function() end
			end
		end)
		att1:GetPropertyChangedSignal("Parent"):Connect(function()
			if not (att1 and att1.Parent) then
				att1 = nil
				fling = function() end
			end
		end)
		local lastfling = nil
		local mouse = lp:GetMouse()
		fling = function(target, duration, rotVelocity)
			if typeof(target) == "Instance" then
				if target:IsA("BasePart") then
					target = target.Position
				elseif target:IsA("Model") then
					target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
					if target then
						target = target.Position
					else
						return
					end
				elseif target:IsA("Humanoid") then
					target = target.Parent
					if not (target and target:IsA("Model")) then
						return
					end
					target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
					if target then
						target = target.Position
					else
						return
					end
				else
					return
				end
			elseif typeof(target) == "CFrame" then
				target = target.Position
			elseif typeof(target) ~= "Vector3" then
				target = mouse.Hit
				if target then
					target = target.Position
				else
					return
				end
			end
			if target.Y < ws.FallenPartsDestroyHeight + 5 then
				target = v3(target.X, ws.FallenPartsDestroyHeight + 5, target.Z)
			end
			lastfling = target
			if type(duration) ~= "number" then
				duration = tonumber(duration) or 0.5
			end
			if typeof(rotVelocity) ~= "Vector3" then
				rotVelocity = v3(20000, 20000, 20000)
			end
			if not (target and flingpart0 and flingpart1 and att0 and att1) then
				return
			end
			flingpart0.Archivable = true
			local flingpart = flingpart0:Clone()
			flingpart.Transparency = 1
			flingpart.CanCollide = false
			flingpart.Name = "flingpart_" .. flingpart0.Name
			flingpart.Anchored = true
			flingpart.Velocity = v3_0
			flingpart.RotVelocity = v3_0
			flingpart.Position = target
			flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
				if not (flingpart and flingpart.Parent) then
					flingpart = nil
				end
			end)
			flingpart.Parent = flingpart1
			flingpart0.Transparency = 0
			att1.Parent = flingpart
			local con = nil
			local rotchg = v3(0, rotVelocity.Unit.Y * -1000, 0)
			con = heartbeat:Connect(function(delta)
				if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
					flingpart.Orientation += rotchg * delta
					flingpart0.RotVelocity = rotVelocity
				else
					con:Disconnect()
				end
			end)
			if alignmode ~= 4 then
				local con = nil
				con = renderstepped:Connect(function()
					if flingpart0 and target then
						flingpart0.RotVelocity = v3_0
					else
						con:Disconnect()
					end
				end)
			end
			twait(duration)
			if lastfling ~= target then
				if flingpart then
					if att1 and (att1.Parent == flingpart) then
						att1.Parent = flingpart1
					end
					pcall(destroy, flingpart)
				end
				return
			end
			target = nil
			if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
				return
			end
			flingpart0.RotVelocity = v3_0
			att1.Parent = flingpart1
			pcall(destroy, flingpart)
		end
	end
end

twait(2)

if not (c and c:IsDescendantOf(ws)) then return end

local hum=c:FindFirstChildOfClass("Humanoid")
assert(hum,"humanoid not found")
hum.RequiresNeck=false
hum.BreakJointsOnDeath=false
local rootpart=hum.RootPart
assert(rootpart,"rootpart not found")
if not pcall(function() readfile("BadApple.mp3") end) then
    if writefile then
        writefile("BadApple.mp3", game:HttpGet("https://somemusic12837.s-ul.eu/9EyizfXw"))
        task.wait(2)
    end
end
local Sound = Instance.new('Sound', c:WaitForChild('Torso', 2))
Sound.SoundId = getcustomasset("BadApple.mp3")
Sound.Volume = 2
Sound.Looped = true
Sound:Play()

local rock = c:WaitForChild('RockAccessory', 2):WaitForChild('Handle', 2)
local sniper = c:WaitForChild('Sniper'):WaitForChild('Handle')
local sog0 = sniper.AccessoryWeld.C0
local sogp1 = sniper.AccessoryWeld.Part1
sniper.AccessoryWeld.Part1 = c:WaitForChild('Right Arm')
sniper.AccessoryWeld.C0 = CFrame.new(-2,-0.5,-0.5) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(90))
local gun = c:WaitForChild('Cyber HsndcannonR'):WaitForChild('Handle')
local gog0 = gun.AccessoryWeld.C0
local gogp1 = gun.AccessoryWeld.Part1
gun.AccessoryWeld.Part1 = c:WaitForChild('Right Arm')
gun.AccessoryWeld.C0 = cf(0,0.4,0.3)*angles(math.rad(145),math.rad(-90),math.rad(187))
rock.Position = Vector3.new(0,0,0)
rock.AccessoryWeld:Destroy()
--rock.SpecialMesh:Destroy()
rock.Anchored = true
rock.Transparency = 0
--if not s then print(f) end
local cf=CFrame.new
local v3=Vector3.new
local v3_0=v3()
local cf_0=cf()
local angles=CFrame.Angles
local Lerp=cf_0.Lerp
local sin=math.sin -- no Cos?
local cos=math.cos -- < 4 custom lerps
local min=math.min
local osclock=os.clock
local twait=task.wait -- ok im gonna redifine everything since this is not working

local function cfMul(a,b) return a*b end

local function getJoint(name)
	local j=nil
	for i,v in ipairs(c:GetDescendants()) do
		if v:IsA("Motor6D") and v.Name==name then
			j=v
			break
		end
	end
	assert(j,"failed to get joint "..name)
	local w=Instance.new("Weld")
	w.Name=j.Name
	w.Part0=j.Part0
	w.Part1=j.Part1
	w.C0=j.C0
	w.C1=j.C1
	local p=j.Parent
	j:Destroy()
	w.Parent=p
	return w
end
local Neck=getJoint("Neck")
local RootJoint=getJoint("RootJoint")
local LeftShoulder=getJoint("Left Shoulder")
local RightShoulder=getJoint("Right Shoulder")
local LeftHip=getJoint("Left Hip")
local RightHip=getJoint("Right Hip")

local rY,lY = 0,0
local Ychg=0

local sine=osclock()
local lastSine=sine

local flinging = false

local mode = 'sniper'

local function rot()
	local mouseRay = workspace.CurrentCamera:ViewportPointToRay(lp:GetMouse().X, lp:GetMouse().Y)
	local planeY = rootpart.Position.Y
	local distance = (planeY - mouseRay.Origin.Y) / mouseRay.Direction.Y
	local targetPosition = mouseRay.Origin + mouseRay.Direction * distance
	local direction = Vector3.new(targetPosition.X, planeY, targetPosition.Z) - rootpart.Position
	rootpart.CFrame = CFrame.lookAt(rootpart.Position, rootpart.Position + direction)
end
lp:GetMouse().KeyDown:Connect(function(key)
	if key:lower() == 'e' then
		if mode == 'sniper' then
			mode = 'gun'
			sniper.AccessoryWeld.C0 = sog0
			sniper.AccessoryWeld.Part1 = sogp1
			gun.AccessoryWeld.C0 = cf(0,0.4,0.3)*angles(math.rad(145),math.rad(-90),math.rad(187))
			gun.AccessoryWeld.Part1 = c:WaitForChild('Right Arm')
		elseif mode == 'gun' then
			mode = 'sniper'
			gun.AccessoryWeld.C0 = gog0
			gun.AccessoryWeld.Part1 = gogp1
			sniper.AccessoryWeld.Part1 = c:WaitForChild('Right Arm')
			sniper.AccessoryWeld.C0 = CFrame.new(-2,-0.5,-0.5) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(90))
		end
	end
end)

lp:GetMouse().Button1Down:Connect(function()
	if flinging then return end
	flinging = true
	hum.UseJumpPower = true
	hum.WalkSpeed = 0
	hum.JumpPower = 0
	if mode == 'sniper' then
		for i = 1,40 do
			sine=osclock()
			local deltaTime=min(1,(sine-lastSine)*10)
			lastSine=sine -- There isn't a fake HB, but still works like a fake HB. I don't even really know how this works but ok.. (i luv this thx myworld)
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.4,0),angles(0,-1.5707963267948966-0.06981317007977318*sin(sine*1.2),0)),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-1.5707963267948966,1.5707963267948966,0)),deltaTime) 
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,1,0),angles(1.5707963267948966,0,0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,-1.5,0),angles(-1.5707963267948966+0.03490658503988659*sin(sine*1),0.03490658503988659*sin((sine+30)*1),3.141592653589793)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,0.4,-0.7),angles(0,-1.5707963267948966,0)),deltaTime) 
			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
			--MW_animatorProgressSave: LeftArm,-1,0,0,1,0,0,0,1,0.4,0,0,1,-90,-4,0,1.2,0,0,0,1,0,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,RightLeg,1,0,0,1,-90,0,0,1,-1,0,0,1,90,0,0,1,0,0,0,1,0,0,0,1,RightArm,1.5,0,0,1,90,0,20,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,2,0,1,-1.5,0,0,1,0,2,30,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,0,0,1,0.4,0,0,1,-90,0,0,1,-0.7,0,0,1,0,0,0,1,Head,0,0,0,1,-90,0,0,1,1,0,0,1,0,0,20,1,0,0,0,1,180,0,0,1
			-- smt like this idk
			twait()
		end
	elseif mode == 'gun' then
		for i = 1,40 do
			sine=osclock()
			local deltaTime=min(1,(sine-lastSine)*10)
			lastSine=sine -- There isn't a fake HB, but still works like a fake HB. I don't even really know how this works but ok.. (i luv this thx myworld)

			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-0.5793895721435547,-0.392061710357666,0.07364007830619812),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cf(-1.5,0.5,-0.5),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(0,1.3962634015954636,0)),deltaTime) 
			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cfMul(cf(-0.8170738816261292,-0.2753200829029083,-0.22283172607421875),angles(0,0,-0.8203047484373349)),deltaTime) 
			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-1.18743896484375,0.46566152572631836,-0.14520263671875),deltaTime) 
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,1,0),angles(1.3962634015954636,0,0)),deltaTime) 
			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966+0.05235987755982989*sin((sine+30)*1),0.03490658503988659*sin(sine*1),3.141592653589793)),deltaTime) 
			--MW_animatorProgressSave: RockAccessory_Handle,-0.5793895721435547,0,0,1,0,0,0,1,-0.392061710357666,0,0,1,0,0,0,1,0.07364007830619812,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,0,0,1,-1,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,1,-0.5,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,0,0,1,-1,0,0,1,80,0,0,1,0,0,0,1,0,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,CyberHsndcannonR_Handle,-1.18743896484375,0,0,1,0,0,0,1,0.46566152572631836,0,0,1,0,0,0,1,-0.14520263671875,0,0,1,0,0,0,1,RightArm,1.5,0,0,1,80,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,Head,0,0,0,1,-90,3,30,1,1,0,0,1,0,2,0,1,0,0,0,1,180,0,0,1


			twait()
		end
	end
	task.wait(0.05)
	-- bla bla
	coroutine.wrap(function()
		fling()
	end)()
	coroutine.wrap(function()
		pcall(function()
			for i = 1,20 do
				task.wait()
				if mode == 'sniper' then
					rock.CFrame = sniper.CFrame
				else
					rock.CFrame = gun.CFrame
				end
			end
			task.wait(0.4)
			for i = 1,20 do
				task.wait()
				rock.CFrame = lp:GetMouse().Hit
			end
		end)
	end)()
	if mode == 'sniper' then
		for i = 1,50 do
			sine=osclock()
			local deltaTime=min(1,(sine-lastSine)*10)
			lastSine=sine -- There isn't a fake HB, but still works like a fake HB. I don't even really know how this works but ok.. (i luv this thx myworld)
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,1,0),angles(1.9198621771937625,0,0)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,0.4,-0.7),angles(0,-1.5707963267948966,0)),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-1.5707963267948966,1.5707963267948966,0)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.4,0),angles(0,-1.5707963267948966-0.06981317007977318*sin(sine*1.2),0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,-1.5,0),angles(-1.5707963267948966+0.03490658503988659*sin(sine*1),0.03490658503988659*sin((sine+30)*1),3.141592653589793)),deltaTime) 

			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966,0,3.141592653589793)),deltaTime) 
			--MW_animatorProgressSave: RightArm,1.5,0,0,1,110,0,20,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,LeftLeg,-1,0,0,1,0,0,0,1,0.4,0,0,1,-90,0,0,1,-0.7,0,0,1,0,0,0,1,RightLeg,1,0,0,1,-90,0,0,1,-1,0,0,1,90,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1,0,0,1,0,0,0,1,0.4,0,0,1,-90,-4,0,1.2,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,2,0,1,-1.5,0,0,1,0,2,30,1,0,0,0,1,180,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,Head,0,0,0,1,-90,0,0,1,1,0,0,1,0,0,20,1,0,0,0,1,180,0,0,1

			-- smt like this idk
			twait()
		end
	elseif mode == 'gun' then
		for i = 1,40 do
			sine=osclock()
			local deltaTime=min(1,(sine-lastSine)*10)
			lastSine=sine -- There isn't a fake HB, but still works like a fake HB. I don't even really know how this works but ok.. (i luv this thx myworld)

			
			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-0.5793895721435547,-0.392061710357666,0.07364007830619812),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cf(-1.5,0.5,-0.5),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(0,1.3962634015954636,0)),deltaTime) 
			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cfMul(cf(-0.8170738816261292,-0.2753200829029083,-0.22283172607421875),angles(0,0,-0.8203047484373349)),deltaTime) 
			--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-1.18743896484375,0.46566152572631836,-0.14520263671875),deltaTime) 
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,1,0),angles(1.9198621771937625,0,0)),deltaTime) 
			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966+0.05235987755982989*sin((sine+30)*1),0.03490658503988659*sin(sine*1),3.141592653589793)),deltaTime) 
			--MW_animatorProgressSave: RockAccessory_Handle,-0.5793895721435547,0,0,1,0,0,0,1,-0.392061710357666,0,0,1,0,0,0,1,0.07364007830619812,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,0,0,1,-1,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,1,-0.5,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,0,0,1,-1,0,0,1,80,0,0,1,0,0,0,1,0,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,CyberHsndcannonR_Handle,-1.18743896484375,0,0,1,0,0,0,1,0.46566152572631836,0,0,1,0,0,0,1,-0.14520263671875,0,0,1,0,0,0,1,RightArm,1.5,0,0,1,110,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,Head,0,0,0,1,-90,3,30,1,1,0,0,1,0,2,0,1,0,0,0,1,180,0,0,1
			twait()
		end
	end
	flinging = false
	hum.UseJumpPower = true
	hum.WalkSpeed = 16
	hum.JumpPower = 50
end) --click fling

while twait() and c and c:IsDescendantOf(ws) do
	Sound:Resume()
	pcall(function()
		rock.Position = rootpart.Position - Vector3.new(0,6,0)
	end)
	if flinging then rot() twait() continue end
	sine=osclock()
	local deltaTime=min(1,(sine-lastSine)*10)
	lastSine=sine -- There isn't a fake HB, but still works like a fake HB. I don't even really know how this works but ok.. (i luv this thx myworld)

	if mode == 'sniper' then
		if hum.FloorMaterial~=Enum.Material.Air then

			if hum.MoveDirection==v3_0 then --idle

				RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
				LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.4,0),angles(0,-1.5707963267948966-0.06981317007977318*sin(sine*1.2),0)),deltaTime) 
				RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(0,1.3962634015954636,0)),deltaTime) 
				Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966-0.08726646259971647*sin(sine*1),-0.08726646259971647*sin((sine+20)*1),3.141592653589793)),deltaTime) 
				RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5,0.5),angles(3.141592653589793+0.05235987755982989*sin((sine+20)*1.3),0,0.08726646259971647*sin(sine*1.3))),deltaTime) 
				LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0,-1.3962634015954636,0)),deltaTime) 
				--MW_animatorProgressSave: Torso,0,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftArm,-1,0,0,1,0,0,0,1,0.4,0,0,1,-90,-4,0,1.2,0,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,0,0,1,-1,0,0,1,80,0,0,1,0,0,0,1,0,0,0,1,Head,0,0,0,1,-90,-5,0,1,1,0,0,1,0,-5,20,1,0,0,0,1,180,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,RightArm,1.5,0,0,1,180,3,20,1.3,0.5,0,0,1,0,0,0,1,0.5,0,0,1,0,5,0,1.3,LeftLeg,-1,0,0,1,0,0,0,1,-1,0,0,1,-80,0,0,1,0,0,0,1,0,0,0,1

			else --walk

				RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1+0.6*sin((sine+20)*8),-0.2+0.2*sin(sine*8)),angles(0.7853981633974483*sin((sine+5)*8),1.5707963267948966,0)),deltaTime) 
				LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.4,0),angles(-0.6981317007977318*sin(sine*8),-1.5707963267948966-0.06981317007977318*sin(sine*1.2),0)),deltaTime) 
				Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966+0.06981317007977318*sin(sine*16),0,3.141592653589793)),deltaTime) 
				RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5,0.5),angles(3.141592653589793+0.03490658503988659*sin((sine+20)*8),0,0.08726646259971647*sin((sine+30)*8))),deltaTime) 
				LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1-0.6*sin((sine+20)*8),-0.2-0.2*sin(sine*8)),angles(-0.7853981633974483*sin((sine+5)*8),-1.5707963267948966,0)),deltaTime) 
				RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.1 * sin(sine*16),0),angles(-1.9198621771937625-0.03490658503988659*sin(sine*16),0,3.141592653589793)),deltaTime) 
				--MW_animatorProgressSave: RightLeg,1,0,0,1,0,45,5,8,-1,0.6,20,8,90,0,0,1,-0.2,0.2,0,8,0,0,0,1,LeftArm,-1,0,0,1,0,-40,0,8,0.4,0,0,8,-90,-4,0,1.2,0,0,0,1,0,0,0,1,Head,0,0,0,1,-90,4,0,16,1,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1,RightArm,1.5,0,0,1,180,2,20,8,0.5,0,0,1,0,0,0,1,0.5,0,0,1,0,5,30,8,LeftLeg,-1,0,0,1,0,-45,5,8,-1,-0.6,20,8,-90,0,0,1,-0.2,-0.2,0,8,0,0,0,1,Torso,0,0,0,1,-110,-2,0,16,0,0.1,0,16,0,0,0,1,0,0,0,1,180,0,0,1
			end
		elseif rootpart.Velocity.Y>0 then --jump

			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1,0.5,0),angles(3.141592653589793,1.9198621771937625+0.17453292519943295*sin(sine*4),0)),deltaTime) 
			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-0.6981317007977318,0,3.141592653589793)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.5,0),angles(3.141592653589793,-1.9198621771937625-0.17453292519943295*sin(sine*4),0)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0.17453292519943295*sin((sine+20)*3),-1.2217304763960306,0)),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-0.17453292519943295*sin((sine+20)*3),1.2217304763960306,0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966+0.08726646259971647*sin(sine*3),0,3.141592653589793),deltaTime) 
			--MW_animatorProgressSave: Accessory(rightarm.001Accessory)_Handle,-0.060161590576171875,0,0,1,0,0,0,1,0.9793415069580078,0,0,1,90,0,0,1,0.0789957046508789,0,0,1,0,0,0,1,RightArm,1,0,0,1,180,0,0,1,0.5,0,0,1,110,10,0,4,0,0,0,1,0,0,0,1,Accessory(rightarm.002Accessory)_Handle,-0.08516311645507812,0,0,1,0,0,0,1,0.19968748092651367,0,0,1,90,0,0,1,0.2521963119506836,0,0,1,0,0,0,1,Head,0,0,0,1,-40,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftArm,-1,0,0,1,0180,0,0,1,0.5,0,0,1,-110,-10,0,4,0,0,0,1,0,0,0,1,LeftLeg,-1,0,0,1,0,10,20,3,-1,0,0,1,-70,0,0,1,0,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,-10,20,3,-1,0,0,1,70,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,5,0,3,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1

		else --fall

			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-2.0943951023931953,0,3.141592653589793)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0.17453292519943295*sin((sine+20)*3),-1.2217304763960306,0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.9198621771937625+0.08726646259971647*sin(sine*3),0,3.141592653589793),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-0.17453292519943295*sin((sine+20)*3),1.2217304763960306,0)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5,0.5,-0.5),angles(0,0,-1.2217304763960306-0.08726646259971647*sin((sine+20)*4))),deltaTime) 
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5,-0.5),angles(0,0,1.2217304763960306+0.08726646259971647*sin((sine+20)*4))),deltaTime) 
			--MW_animatorProgressSave: Head,0,0,0,1,-120,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,10,20,3,-1,0,0,1,-70,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-110,5,0,3,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,Accessory(rightarm.002Accessory)_Handle,-0.08516311645507812,0,0,1,0,0,0,1,0.19968748092651367,0,0,1,90,0,0,1,0.2521963119506836,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,-10,20,3,-1,0,0,1,70,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,0,-0.5,0,0,1,-70,-5,20,4,Accessory(rightarm.001Accessory)_Handle,-0.060161590576171875,0,0,1,0,0,0,1,0.9793415069580078,0,0,1,90,0,0,1,0.0789957046508789,0,0,1,0,0,0,1,RightArm,1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,0,-0.5,0,0,1,70,5,20,4

		end
	elseif mode == 'gun' then
		if hum.FloorMaterial~=Enum.Material.Air then

			if hum.MoveDirection==v3_0 then --idle

				RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5+0.05*sin(sine*2),-0.5),angles(0,0.08726646259971647*sin((sine+10)*2),0.2617993877991494+0.08726646259971647*sin((sine+15)*2))),deltaTime) 
				Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-1.5707963267948966+0.08726646259971647*sin((sine+30)*1.5),0.08726646259971647*sin(sine*1.5),3.141592653589793)),deltaTime) 
				--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-0.5793895721435547,-0.392061710357666,0.07364007830619812),deltaTime) 
				--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cf(-1.18743896484375,0.46566152572631836,-0.14520263671875),deltaTime) 
				RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(0,1.3962634015954636,0)),deltaTime) 
				LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5,0.4+0.03*sin(sine*2),-0.5),angles(0,-0.05235987755982989*sin((sine+10)*2),0.08726646259971647)),deltaTime) 
				LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0,-1.5707963267948966,0)),deltaTime) 
				RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
				--AccessoryWeld.C0=Lerp(AccessoryWeld.C0,cfMul(cf(-0.8170738816261292,-0.2753200829029083,-0.22283172607421875),angles(0,0,-0.8203047484373349)),deltaTime) 
				--MW_animatorProgressSave: RightArm,1.5,0,0,1,0,0,0,1,0.5,0.05,0,2,0,5,10,2,-0.5,0,0,1,15,5,15,2,Head,0,0,0,1,-90,5,30,1.5,1,0,0,1,0,5,0,1.5,0,0,0,1,180,0,0,1,RockAccessory_Handle,-0.5793895721435547,0,0,1,0,0,0,1,-0.392061710357666,0,0,1,0,0,0,1,0.07364007830619812,0,0,1,0,0,0,1,CyberHsndcannonR_Handle,-1.18743896484375,0,0,1,0,0,0,1,0.46566152572631836,0,0,1,0,0,0,1,-0.14520263671875,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,0,0,1,-1,0,0,1,80,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.4,0.03,0,2,0,-3,10,2,-0.5,0,0,1,5,0,0,1,LeftLeg,-1,0,0,1,0,0,0,1,-1,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,Sniper_Handle,-0.8170738816261292,0,0,1,0,0,0,1,-0.2753200829029083,0,0,1,0,0,0,1,-0.22283172607421875,0,0,1,-47,0,0,1
			else --walk

				Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1+0.02*sin((sine+15)*16),0),angles(-1.5707963267948966+0.05235987755982989*sin(sine*16),0,3.141592653589793)),deltaTime) 
				RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5,-0.5+0.1*sin((sine+15)*8)),angles(-0.08726646259971647-0.3490658503988659*sin((sine+15)*8),0,0.2617993877991494+0.03490658503988659*sin(sine*16))),deltaTime) 
				RootJoint.C0=Lerp(RootJoint.C0,cfMul(cf(0,0.1 * sin(sine*16),0),angles(-1.8500490071139892+0.05235987755982989*sin((sine+15)*16),0,3.141592653589793)),deltaTime) 
				LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1-0.6*sin((sine+20)*8),-0.2-0.2*sin(sine*8)),angles(-0.7853981633974483*sin((sine+5)*8),-1.5707963267948966,0)),deltaTime) 
				LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5,0.4+0.04*sin(sine*16),-0.5),angles(0,-0.05235987755982989*sin((sine+10)*2),0.08726646259971647)),deltaTime) 
				RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1+0.6*sin((sine+20)*8),-0.2+0.2*sin(sine*8)),angles(0.7853981633974483*sin((sine+5)*8),1.5707963267948966,0)),deltaTime) 
				--MW_animatorProgressSave: CyberHsndcannonR_Handle,-1.18743896484375,0,0,1,0,0,0,1,0.46566152572631836,0,0,1,0,0,0,1,-0.14520263671875,0,0,1,0,0,0,1,Head,0,0,0,1,-90,3,0,16,1,0.02,15,16,0,0,0,1,0,0,0,1,180,0,0,1,RightArm,1.5,0,0,1,-5,-20,15,8,0.5,0,0,1,0,0,0,1,-0.5,0.1,15,8,15,2,0,16,RockAccessory_Handle,-0.5793895721435547,0,0,1,0,0,0,1,-0.392061710357666,0,0,1,0,0,0,1,0.07364007830619812,0,0,1,0,0,0,1,Torso,0,0,0,1,-106,3,15,16,0,0.1,0,16,0,0,0,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,-45,0,8,-1.1,-0.2,0,8,-90,0,0,1,0,0.3,0,8,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.4,0.04,0,16,0,-3,10,2,-0.5,0,0,1,5,0,0,1,RightLeg,1,0,0,1,0,45,0,8,-1.1,0.2,0,8,90,0,0,1,0,-0.3,0,8,0,0,0,1

			end
		elseif rootpart.Velocity.Y>0 then --jump

			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1,0.5,0),angles(3.141592653589793,1.9198621771937625+0.17453292519943295*sin(sine*4),0)),deltaTime) 
			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-0.6981317007977318,0,3.141592653589793)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1,0.5,0),angles(3.141592653589793,-1.9198621771937625-0.17453292519943295*sin(sine*4),0)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0.17453292519943295*sin((sine+20)*3),-1.2217304763960306,0)),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-0.17453292519943295*sin((sine+20)*3),1.2217304763960306,0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.5707963267948966+0.08726646259971647*sin(sine*3),0,3.141592653589793),deltaTime) 
			--MW_animatorProgressSave: Accessory(rightarm.001Accessory)_Handle,-0.060161590576171875,0,0,1,0,0,0,1,0.9793415069580078,0,0,1,90,0,0,1,0.0789957046508789,0,0,1,0,0,0,1,RightArm,1,0,0,1,180,0,0,1,0.5,0,0,1,110,10,0,4,0,0,0,1,0,0,0,1,Accessory(rightarm.002Accessory)_Handle,-0.08516311645507812,0,0,1,0,0,0,1,0.19968748092651367,0,0,1,90,0,0,1,0.2521963119506836,0,0,1,0,0,0,1,Head,0,0,0,1,-40,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftArm,-1,0,0,1,0180,0,0,1,0.5,0,0,1,-110,-10,0,4,0,0,0,1,0,0,0,1,LeftLeg,-1,0,0,1,0,10,20,3,-1,0,0,1,-70,0,0,1,0,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,-10,20,3,-1,0,0,1,70,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-90,5,0,3,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1

		else --fall

			Neck.C0=Lerp(Neck.C0,cfMul(cf(0,1,0),angles(-2.0943951023931953,0,3.141592653589793)),deltaTime) 
			LeftHip.C0=Lerp(LeftHip.C0,cfMul(cf(-1,-1,0),angles(0.17453292519943295*sin((sine+20)*3),-1.2217304763960306,0)),deltaTime) 
			RootJoint.C0=Lerp(RootJoint.C0,angles(-1.9198621771937625+0.08726646259971647*sin(sine*3),0,3.141592653589793),deltaTime) 
			RightHip.C0=Lerp(RightHip.C0,cfMul(cf(1,-1,0),angles(-0.17453292519943295*sin((sine+20)*3),1.2217304763960306,0)),deltaTime) 
			LeftShoulder.C0=Lerp(LeftShoulder.C0,cfMul(cf(-1.5,0.5,-0.5),angles(0,0,-1.2217304763960306-0.08726646259971647*sin((sine+20)*4))),deltaTime) 
			RightShoulder.C0=Lerp(RightShoulder.C0,cfMul(cf(1.5,0.5,-0.5),angles(0,0,1.2217304763960306+0.08726646259971647*sin((sine+20)*4))),deltaTime) 
			--MW_animatorProgressSave: Head,0,0,0,1,-120,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,LeftLeg,-1,0,0,1,0,10,20,3,-1,0,0,1,-70,0,0,1,0,0,0,1,0,0,0,1,Torso,0,0,0,1,-110,5,0,3,0,0,0,1,0,0,0,1,0,0,0,1,180,0,0,1,Accessory(rightarm.002Accessory)_Handle,-0.08516311645507812,0,0,1,0,0,0,1,0.19968748092651367,0,0,1,90,0,0,1,0.2521963119506836,0,0,1,0,0,0,1,RightLeg,1,0,0,1,0,-10,20,3,-1,0,0,1,70,0,0,1,0,0,0,1,0,0,0,1,LeftArm,-1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,0,-0.5,0,0,1,-70,-5,20,4,Accessory(rightarm.001Accessory)_Handle,-0.060161590576171875,0,0,1,0,0,0,1,0.9793415069580078,0,0,1,90,0,0,1,0.0789957046508789,0,0,1,0,0,0,1,RightArm,1.5,0,0,1,0,0,0,1,0.5,0,0,1,0,0,0,0,-0.5,0,0,1,70,5,20,4

		end
	end
end